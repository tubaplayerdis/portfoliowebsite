{
  "introparagraph": "JReverse was initially created to aid in the development of JNI modifications of Java Applications, and as it progressed, it became more of a platform for the reverse engineering of java applications. While this might not initially seem important compared to the creation of a program in any language, being able to understand another program by looking inside requires language skills like no other, and with that requirement comes immense growth in the language. I chose Java due to my use of it in formal education and a desire to learn more about the language. This was the correct choice, as Java includes comprehensive tools to dive deep into the language such as the JNI and JVMTI, which is the foundation of JReverse.",
  "bodyparagraph1": "JReverse had a smooth start to development and quickly progressed into a fully working application within days. Since I had previous experience with c# and formal Java education, I was able to pick up java quickly, taking some time to learn build systems such as Maven and Gradle, and eventually deciding on Gradle for JReverse. Then I decided on a system for JReverse; A Gui that is written in Java and uses a JNI library using IPC(Inter-Process-Communication) to communicate with an injected library on a host application. The libraries are called JReverseBridge and JReverseCore respectively.  Next was to create the underlying libraries for the JReverse GUI, JReverseBridge and JReverseCore. I will be referring to JReverseBridge and JReverseCore as the “bridge”, and the “core” from now on. The bridge and core are both written in c++, which is a language I was familiar with since I have used it extensively in past projects, even if most went unfinished. The bridge uses the JNI to interact with JReverse’s GUI and the core uses the JNI and the JVMTI to interact with the host application. The bridge and core communicate using boost’s IPC libraries. After creating a standardized and templated communication system for the bridge and core, along with a simple GUI, I had the first working version of JReverse, after days of trial and error and reading A LOT of documentation.",
  "bodyparagraph2": "JReverse’s primary development is going steady, with new features being added as time progresses. One of the first things that was implemented was information collection on classes, such as static modifiers, flags, private methods, public methods, fields, and bytecode collection. After bytecode collection was implemented, then came an embedded decompiler for it. I did not write the decompiler and instead used CFR. This allows for real time analysis of source code to see what is happening. Unfortunately, the JVM does not just keep bytecode in useful form inside application memory, instead only on load of classes. Using this knowledge, I was able to create a system that allowed for the starting and instant attachment of JReverse to a host process, which allowed for more comprehensive source code analysis as in almost every class being collected. Next was a Scripting Engine for JReverse. Initially this would seem like an abstract idea as I could load my own classes onto the JVM, but there is one crucial feature missing, Instanced class calling. Therefore I decided to try out some scripting engines and came across Jython, which worked the best for me. Using Jython and the JVMTI, I created a JVMTI based system that allowed calling methods and modifying on instanced classes like they were static from Jython, therefore allowing more in depth modification and analysis of java applications. Then I created systems to dump information related to classes and the application, in a standard format or source code so they could be used in reference docs or source code. Next I worked on a system to intercept/change source code with a class editor and “rules” upon injection. What this is, is a way to modify source code right before it is loaded and therefore change it, or change it for future classes. Then I worked on quality of life and general improvements, such as a settings menu using my data format SSTF, and a version control system for the core that used google drive and google scripts, so it would not need to be downloaded every time there was an update, and a dynamic class file collection system so source code could be collected upon class load. Finally, I reworked the IPC communication system between the bridge and core to allow for future features to work better and primarily, reconnection after a crash. This main stint of progress was during the end of my sophomore year of high school, with a small break happening to study for finals.",
  "bodyparagraph3": "Currently I am working on some finishing features on JReverse such as testing on the version control and working on the ui for certain aspects such as the class loader. Most importantly I am working on developing an installer for the application along with an updater built into it. In terms of the future I plan to produce a few major features such as an embedded GUI in the core and a console interface for extra debugging features, along with more feedback features like progress bars and console capture. I then plan to make smaller updates as time progresses. Things might change, but for the foreseeable future this is the plan."
}